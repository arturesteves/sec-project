package pt.ulisboa.tecnico.sec.g19.hdscoin.server;

import com.fasterxml.jackson.core.JsonProcessingException;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import pt.ulisboa.tecnico.sec.g19.hdscoin.common.Serialization;
import pt.ulisboa.tecnico.sec.g19.hdscoin.common.Utils;
import pt.ulisboa.tecnico.sec.g19.hdscoin.common.execeptions.CantGenerateSignatureException;
import pt.ulisboa.tecnico.sec.g19.hdscoin.server.exceptions.FailedToLoadKeysException;
import pt.ulisboa.tecnico.sec.g19.hdscoin.common.execeptions.InvalidAmountException;
import pt.ulisboa.tecnico.sec.g19.hdscoin.common.execeptions.InvalidLedgerException;
import pt.ulisboa.tecnico.sec.g19.hdscoin.server.exceptions.MissingLedgerException;
import pt.ulisboa.tecnico.sec.g19.hdscoin.server.structures.Ledger;

import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.*;
import java.security.interfaces.ECPrivateKey;
import java.security.interfaces.ECPublicKey;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.*;

import pt.ulisboa.tecnico.sec.g19.hdscoin.server.structures.Transaction;
import spark.Request;
import spark.Response;

import static pt.ulisboa.tecnico.sec.g19.hdscoin.common.Serialization.StatusMessage.*;
import static spark.Spark.post;
import static spark.Spark.get;
import static spark.Spark.trace;


public class Main {
    private final static Logger log = Logger.getLogger(Main.class.getName());

    private static ECPublicKey serverPublicKey;
    private static ECPrivateKey serverPrivateKey;

    private static Object ledgerLock = new Object();

    public static void main(String[] args) throws FailedToLoadKeysException {
        // set Logger
        Utils.initLogger(log);
        Security.addProvider(new BouncyCastleProvider());
        log.log(Level.CONFIG, "Added bouncy castle security provider.");

        try {
            loadKeys(args[0]);
            log.log(Level.INFO, "Loaded keys of the server.");

        } catch (KeyException | IOException e) {
            log.log(Level.SEVERE, "Failed to load keys from file. " + e);
            throw new FailedToLoadKeysException("Failed to load keys from file. " + e.getMessage(), e);
        }

        try {
            Database.recreateSchema();
            log.log(Level.INFO, "Recreate database schema.");
        } catch (SQLException e) {
            log.log(Level.SEVERE, "Failed to recreate database schema. " + e);
            e.printStackTrace();
            System.exit(-1);
        }

        post("/register", "application/json", (req, res) -> {

            Serialization.RegisterRequest request = null;
            try {
                request = Serialization.parse(req, Serialization.RegisterRequest.class);
                log.log(Level.INFO, "Request received at: /register \n" +
                        "data on the request: \n" +
                        "\tSIGNATURE: " + req.headers(Serialization.SIGNATURE_HEADER_NAME) + "\n" +
                        "\tNONCE: " + request.nonce + "\n" +
                        "\tCLIENT BASE 64 PUBLIC KEY: " + request.key + "\n" +
                        "\tAMOUNT: " + request.amount);

                Boolean result = false; // false to defend
                try {
                    //Recreate the hash with the data received
                    result = Utils.checkSignature(
                            req.headers(Serialization.SIGNATURE_HEADER_NAME),
                            request.getSignable(),
                            request.key);

                    System.out.println("SIGN val: " + result);
                } catch (CantGenerateSignatureException e) {
                    log.log(Level.WARNING, "The signature of the message received from the client doesn't match " +
                            "with the signature of the message generated by the server. " + e);
                }

                Serialization.Response response = new Serialization.Response();
                response.nonce = request.nonce;

                if (!result) {
                    res.status(401);
                    response.status = ERROR_NO_SIGNATURE_MATCH;
                    log.log(Level.WARNING, "Client signature not verified.");
                    return prepareResponse(serverPrivateKey, req, res, response);
                }

                ///////////////////////////////////////////////////
                //We now know that the public key was sent by the owner of its respective private key.
                ///////////////////////////////////////////////////

                Connection conn = null;
                String key = request.key;
                try {
                    conn = Database.getConnection();
                    // mutual exclusion is necessary to ensure the new ledger ID obtained in "new Ledger"
                    // is still correct/"fresh" when "ledger.persist" is called.
                    synchronized (ledgerLock) {
                        Ledger ledger = new Ledger(conn, Serialization.base64toPublicKey(key), request.amount);
                        ledger.persist(conn);
                        conn.commit();
                    }
                    response.status = SUCCESS;
                    log.log(Level.INFO, "Initialized a new ledger with the base 64 public key: " + key);
                } catch (SQLException e) {
                    // servers fault
                    log.log(Level.SEVERE, "Error related to the database. " + e);
                    response.status = ERROR_SERVER_ERROR;
                }
                // these exceptions are the client's fault
                catch (InvalidLedgerException e) {
                    response.status = ERROR_INVALID_LEDGER;
                } catch (InvalidAmountException e) {
                    response.status = ERROR_INVALID_AMOUNT;
                } catch (InvalidKeyException e) {
                    response.status = ERROR_INVALID_KEY;
                } finally {
                    if (!response.status.equals(SUCCESS) && conn != null) {
                        conn.rollback();
                        log.log(Level.SEVERE, "The ledger created with the following public key was not " +
                                "persisted. Public Key: " + request.key);
                    }
                }

                return prepareResponse(serverPrivateKey, req, res, response);
            } catch (Exception ex) {
                res.status(500);
                Serialization.Response response = new Serialization.Response();
                response.nonce = (request != null ? request.nonce : "");
                response.status = ERROR_SERVER_ERROR;
                log.log(Level.SEVERE, "Error on processing a register request. " + ex);
                return prepareResponse(serverPrivateKey, req, res, response);
            }
        });

        post("/sendAmount", "application/json", (req, res) -> {

            try {
                Serialization.SendAmountRequest request = Serialization.parse(req,
                        Serialization.SendAmountRequest.class);
                log.log(Level.INFO, "Request received at: /sendAmount \n" +
                        "data on the request:" +
                        "SIGNATURE: " + req.headers(Serialization.SIGNATURE_HEADER_NAME) + "\n" +
                        "NONCE: " + req.headers(Serialization.NONCE_HEADER_NAME) + "\n" +
                        "AMOUNT:" + request.amount + "\n" +
                        "SOURCE CLIENT BASE 64 PUBLIC KEY: " + request.source + "\n" +
                        "TARGET CLIENT BASE 64 PUBLIC KEY: " + request.target);

                Serialization.Response response = new Serialization.Response();

                //Recreate the hash with the data received
                Boolean result = Utils.checkSignature(
                        req.headers(Serialization.SIGNATURE_HEADER_NAME),
                        request.getSignable(),
                        request.source);

                if (!result) {
                    res.status(401);
                    log.log(Level.WARNING, "The message received from the client doesn't match with the " +
                            "signature of the message.");
                    response.status = ERROR_NO_SIGNATURE_MATCH;
                    return prepareResponse(serverPrivateKey, req, res, response);
                }

                ///////////////////////////////////////////////////
                //We now know that the public key was sent by the owner of its respective private key.
                ///////////////////////////////////////////////////

                Connection conn = null;
                try {
                    conn = Database.getConnection();
                    Ledger sourceLedger = Ledger.load(conn, Serialization.base64toPublicKey(request.source));
                    Ledger targetLedger = Ledger.load(conn, Serialization.base64toPublicKey(request.target));

                    Transaction transaction = new Transaction(conn, sourceLedger, targetLedger, request.amount,
                            req.headers(Serialization.NONCE_HEADER_NAME),
                            req.headers(Serialization.SIGNATURE_HEADER_NAME),
                            request.previousSignature, Transaction.TransactionTypes.SENDING);
                    // checkout the amount from the source ledger
                    sourceLedger.setAmount(sourceLedger.getAmount() - request.amount);
                    transaction.persist(conn);
                    sourceLedger.persist(conn);
                    conn.commit();
                    response.status = SUCCESS;
                    log.log(Level.INFO, "Transaction created with success.");
                } catch (SQLException e) {
                    // servers fault
                    log.log(Level.SEVERE, "Error related to the databas. " + e);
                    response.status = ERROR_SERVER_ERROR;
                }
                // these exceptions are the client's fault
                catch (MissingLedgerException e) {
                    response.status = ERROR_INVALID_LEDGER;
                } catch (InvalidKeyException e) {
                    response.status = ERROR_INVALID_KEY;
                } finally {
                    if (!response.status.equals(SUCCESS) && conn != null) {
                        conn.rollback();
                        log.log(Level.SEVERE, "The transaction created was not persisted, due to an error.");
                    }
                }

                return prepareResponse(serverPrivateKey, req, res, response);
            } catch (Exception ex) {
                res.status(500);
                Serialization.Response response = new Serialization.Response();
                response.status = ERROR_SERVER_ERROR;
                log.log(Level.SEVERE, "Error on processing a send amount request. " + ex);
                return prepareResponse(serverPrivateKey, req, res, response);
            }
        });

        get("/checkAccount", "application/json", (req, res) -> {
            try {
                String b64PublicKey = req.queryParamOrDefault("publickey", "")
                        .replace(" ", "+");    // to be sure
                log.log(Level.INFO, "Request received at: /checkAccount \n" +
                        "data on the request:" +
                        "public key: " + b64PublicKey);

                // init generic response to use when an error occur
                Serialization.Response errorResponse = new Serialization.Response();
                try {
                    Serialization.CheckAccountResponse response = new Serialization.CheckAccountResponse();
                    ECPublicKey clientPublicKey = Serialization.base64toPublicKey(b64PublicKey);
                    Connection conn = Database.getConnection();
                    Ledger ledger = Ledger.load(conn, clientPublicKey);
                    System.out.println("Pending" + ledger.getPendingTransactions(conn, clientPublicKey));
                    response.balance = ledger.getAmount();
                    response.pendingTransactions = ledger.getPendingTransactions(conn, clientPublicKey);
                    System.out.printf("Balance: " + response.balance);

                    response.status = SUCCESS;
                    log.log(Level.INFO, "Successful check account operation of the ledger with the " +
                            "following public key in base 64: " + b64PublicKey);
                    return prepareResponse(serverPrivateKey, req, res, response);
                } catch (SQLException e) {
                    // servers fault
                    log.log(Level.SEVERE, "Error related to the database. " + e);
                    errorResponse.status = ERROR_SERVER_ERROR;
                }
                // these exceptions are the client's fault
                catch (MissingLedgerException e) {
                    errorResponse.status = ERROR_INVALID_LEDGER;
                } catch (InvalidKeyException e) {
                    errorResponse.status = ERROR_INVALID_KEY;
                }
                return prepareResponse(serverPrivateKey, req, res, errorResponse);
            } catch (Exception ex) {
                res.status(500);
                Serialization.Response response = new Serialization.Response();
                response.status = ERROR_SERVER_ERROR;
                log.log(Level.SEVERE, "Error on processing a check account request. " + ex);
                return prepareResponse(serverPrivateKey, req, res, response);
            }
        });

        post("/receiveAmount", "application/json", (req, res) -> {

            try {
                Serialization.ReceiveAmountRequest request = Serialization.parse(req,
                        Serialization.ReceiveAmountRequest.class);

                log.log(Level.INFO, "Request received at: /receiveAmount \n" +
                        "data on the request:" +
                        "SIGNATURE: " + req.headers(Serialization.SIGNATURE_HEADER_NAME) + "\n" +
                        "NONCE: " + req.headers(Serialization.NONCE_HEADER_NAME) + "\n" +
                        "SOURCE CLIENT BASE 64 PUBLIC KEY: " + request.source + "\n" +
                        "Transaction Signature: " + request.transactionSignature);

                Serialization.Response response = new Serialization.Response();

                //Recreate the hash with the data received
                Boolean result = Utils.checkSignature(
                        req.headers(Serialization.SIGNATURE_HEADER_NAME),
                        request.getSignable(),
                        request.source);

                if (!result) {
                    res.status(401);
                    log.log(Level.WARNING, "The message received from the client doesn't match with the " +
                            "signature of the message.");
                    response.status = ERROR_NO_SIGNATURE_MATCH;
                    return prepareResponse(serverPrivateKey, req, res, response);
                }

                ///////////////////////////////////////////////////
                //We now know that the public key was sent by the owner of its respective private key.
                ///////////////////////////////////////////////////

                Connection conn = null;
                try {
                    conn = Database.getConnection();
                    ECPublicKey publicKey = Serialization.base64toPublicKey(request.source);
                    Ledger targetLedger = Ledger.load(conn, publicKey);

                    Transaction txReceived = Ledger.getPendingTransaction(conn, publicKey, request.transactionSignature,
                            Transaction.TransactionTypes.RECEIVING);

                    if (txReceived != null) {
                        Transaction txSent = Ledger.getPendingTransaction(conn, publicKey, request.transactionSignature,
                                Transaction.TransactionTypes.SENDING);
                    } else {
                        // nothing ..
                    }

                    /*
                    Transaction txSent = sourceLedger.getPendingTransaction(conn, publicKey, request.transactionSignature,
                            Transaction.TransactionTypes.SENDING);
                    if (txSent != null) {
                        Transaction txReceived = sourceLedger.getPendingTransaction(conn, publicKey, request.transactionSignature,
                                Transaction.TransactionTypes.RECEIVING);
                        txSent.setPending(false);
                        if (txReceived != null) {
                            // sum the amount to the target
                            txSent.getTargetLedger().setAmount(txSent.getTargetLedger().getAmount() + txSent.getAmount());

                            txReceived.setPending(false);
                            // actualizar o balanco da account
                            txSent.persist(conn);
                            txSent.getTargetLedger().persist(conn);
                            //// transaction finalized!
                        }
                    } else {
                        // no transaction - error - operation no t successful

                    }
                    */
                } catch (SQLException e) {
                    // servers fault
                    log.log(Level.SEVERE, "Error related to the databas. " + e);
                    response.status = ERROR_SERVER_ERROR;
                }
                // these exceptions are the client's fault
                catch (MissingLedgerException e) {
                    response.status = ERROR_INVALID_LEDGER;
                } catch (InvalidKeyException e) {
                    response.status = ERROR_INVALID_KEY;
                } finally {
                    if (!response.status.equals(SUCCESS) && conn != null) {
                        conn.rollback();
                        log.log(Level.SEVERE, "The transaction created was not persisted, due to an error.");
                    }
                }

                return prepareResponse(serverPrivateKey, req, res, response);

            } catch (Exception ex) {
                res.status(500);
                Serialization.Response response = new Serialization.Response();
                response.status = ERROR_SERVER_ERROR;
                log.log(Level.SEVERE, "Error on processing a receive amount request. " + ex);
                return prepareResponse(serverPrivateKey, req, res, response);
            }
        });

        get("/audit/:key", "application/json", (req, res) -> {
            Serialization.Response errorResponse = new Serialization.Response();
            String pubKeyBase64 = req.params(":key");
            if (pubKeyBase64 == null) {
                errorResponse.status = ERROR_MISSING_PARAMETER;
                return prepareResponse(serverPrivateKey, req, res, errorResponse);
            }
            System.out.println("Going to send audit data for public key: " + pubKeyBase64);

            Connection conn = null;
            try {
                Serialization.AuditResponse response = new Serialization.AuditResponse();
                conn = Database.getConnection();
                ECPublicKey publicKey = Serialization.base64toPublicKey(req.params(":key"));
                Ledger ledger = Ledger.load(conn, publicKey);

                List<Transaction> transactions = ledger.getAllTransactions(conn);
                for(Transaction tx : transactions) {
                    Serialization.Transaction serializedTx = new Serialization.Transaction();
                    serializedTx.source = Serialization.publicKeyToBase64(tx.getSourceLedger().getPublicKey());
                    serializedTx.target = Serialization.publicKeyToBase64(tx.getTargetLedger().getPublicKey());
                    serializedTx.isSend = tx.getTransactionType() == Transaction.TransactionTypes.SENDING;
                    serializedTx.amount = tx.getAmount();
                    serializedTx.previousSignature = tx.getPreviousHash();
                    response.transactions.add(serializedTx);
                }
                conn.commit();
                response.status = SUCCESS;
                return prepareResponse(serverPrivateKey, req, res, response);
            } catch (MissingLedgerException e) {
                errorResponse.status = ERROR_INVALID_LEDGER;
            } catch (InvalidKeyException e) {
                errorResponse.status = ERROR_INVALID_KEY;
            } catch (SQLException e) {
                // servers fault
                log.log(Level.SEVERE, "Error related to the databas. " + e);
                errorResponse.status = ERROR_SERVER_ERROR;
            }
            if(conn != null) {
                try {
                    conn.rollback();
                } catch(SQLException ex) {
                    // oh well
                }
            }
            return prepareResponse(serverPrivateKey, req, res, errorResponse);
        });
    }

    private static String prepareResponse(ECPrivateKey privateKey, Request sparkRequest, Response sparkResponse, Serialization.Response response) throws JsonProcessingException, CantGenerateSignatureException {
        if (response.statusCode < 0) {
            // try to guess a status code from the status string
            switch (response.status) {
                case SUCCESS:
                    response.statusCode = 200;
                    break;
                case ERROR_SERVER_ERROR:
                    response.statusCode = 500;
                    break;
                default:
                    // all other errors are problems with the request
                    response.statusCode = 400;
            }
        }
        String signature = Utils.generateSignature(response.getSignable(), privateKey);
        sparkResponse.status(response.statusCode);
        sparkResponse.header(Serialization.SIGNATURE_HEADER_NAME, signature);
        sparkResponse.type("application/json");
        return Serialization.serialize(response);
    }

    private static void loadKeys(String serverName) throws KeyException, IOException {
        String root = System.getProperty("user.dir");
        String filepath = root + Serialization.SERVER_PACKAGE_PATH + "\\keys\\" + serverName + ".keys";
        Path path = Paths.get(filepath).normalize();

        serverPublicKey = Utils.readPublicKeyFromFile(path.toString());
        serverPrivateKey = Utils.readPrivateKeyFromFile(path.toString());
    }

}